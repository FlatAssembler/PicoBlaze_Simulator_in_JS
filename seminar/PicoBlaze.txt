Simulator PicoBlaze ra?unala u JavaScriptu

Autor: Teo Samar?ija

SA?ETAK: Autor teksta bio je frustriran nedostacima postoje?ih simulatora malog ra?unala PicoBlaze, te je napravio druk?iji simulator PicoBlazea u programskom jeziku JavaScript. Taj se simulator mo?e pokrenuti u modernim internetskim preglednicima1 (autor misli da je najstariji internetski preglednik u kojem simulator funkcionira kako treba Firefox 52, posljednja verzija Firefoxa koja se mo?e vrtjeti na Windows XP-u). U tekstu slijede detalji o tome kako je autor napravio svoj simulator te koje su prednosti i mane tog simulatora u usporedbi s ve? postoje?im simulatorima. Nisu kori?teni nikakvi radni okviri (frameworksi), kôd je pisan uglavnom u VIM-u (za manje izmjene) i Eclipseu (za ve?e izmjene), za ure?ivanje slika kori?teni su GIMP i Inkscape, za tra?enje pogre?aka u programu kori?teni su alati za programiranje koji se dobiju uz Firefox i internetski servis LGTM. Za formatiranje koda kori?teni su Prettier (za HTML i CSS) i ClangFormat (za JavaScript).

Uvod
PicoBlaze (od latinskog piccus, rupica na igli, u prenesenom zna?enju ne?to maleno, i engleskog blaze, plamen. Latinska rije? piccus mo?da je povezana s picus, djetli?, jer djetli? svojim kljunom bu?i drvo. Engleska rije? blaze dijeli isti korijen kao i latinski flamma. Od latinske rije?i flamma dolazi, preko francuskog, danas daleko poznatija engleska rije? za plamen, flame. Hrvatska rije? plamen vjerojatno nije povezana s latinskim flamma.) je malo ra?unalo koji proizvodi tvrtka Xilinx. Koristi se u ugra?enim sustavima, te kao primjer jednostavnog ra?unala na kolegiju Arhitektura ra?unala na FERIT-u. Njegov je procesor dizajniran tako da se u cijelosti mo?e implementirati programibilnim elektroni?kim sklopovima (FPGA-ovima, ASIC-ima...), te je pisan u programskom jeziku VHDL. Takvi procesori zovu se mekani procesori (soft processor). PicoBlazeov procesor razlikuje se po mnogo ?emu od procesora kori?tenih u stolnim ra?unalima (koje proizvode tvrtke Intel i AMD) i procesora u mobilnim telefonima i tabletima (uglavnom ARM-ovi procesori), i potreban nam je simulator da bismo pokrenuli programe za njega na ra?unalu na kojem programiramo. Dok programiramo za male ure?aje, korisno je mo?i pokrenuti program na ra?unalu na kojem programiramo radi testiranja ili tra?enja pogre?ke u programu. Simulator je program koji omogu?uje ra?unalu da se pretvara da je nekakvo druk?ije ra?unalo. Rije? simulator zna?i onaj koji kopira ili imitira, dolazi iz latinskog i prvi put se spominje u Ovidijevim Metamorfozama (11. poglavlje, 634. stih). Dolazi od simulare (pretvarati se), od similis (sli?an). PicoBlaze vjerojatno ne mo?e pokrenuti alate za programiranje (ako i mo?e, oni bi bili jako spori i neprakti?ni za kori?tenje - daleko lo?iji od alata za programiranje mobitela koji se pokre?u na mobitelima), on bez kori?tenja pomo?nih ure?aja mo?e koristiti svega 0.25 KB memorije za spremanje podataka i 9 KB-a memorije za spremanje programa. Za usporedbu, simulator koji je autor napravio velik je 196 KB, a jedna disketa mo?e sadr?avati, ovisi kako je formatirana, do 2'000 KB podataka (obi?no se formatira u FAT12 format, jer je jedini razlog za?to se diskete danas koriste kompatibilnost s prastarim ra?unalima koja jedino to i podr?avaju, a FAT12 format dopu?ta da se koristi oko 1'400 KB). Za simuliranje PicoBlazea naj?e??e se koriste FIDEX, koji proizvodi tvrtka Fautronix, ili Xilinx ISE, koji, naravno, proizvodi tvrtka Xilinx. Postoje legalne besplatne verzije tih programa koji se mogu skinuti s interneta, i te besplatne verzije podr?avaju vjerojatno sve ?to nekome treba, tako da cijena nije problem.

Eclipse
Eclipse (nazvan po gr?koj rije?i za pomr?inu) je besplatan IDE (integrated developing environment, program namijenjen da se u njemu pi?e kod u programskom jeziku i koji olak?ava rukovanje raznim alatima za programiranje) primarno namijenjen za pisanje programa u Javi. Prva verzija izdana je 2001. godine. Me?utim, danas Eclipse pru?a relativno dobru podr?ku i za JavaScript, te je velik dio koda ovog simulatora napisan u njemu. Prednost nad VIM-om je to ?to koristi TypeScript Service (TypeScript je programski jezik koji je dizajnirao Microsoft, on se prevodi u JavaScript i Microsoft tvrdi da olak?ava automatsko tra?enje gre?aka u programima) kako bi davao smislene sugestije za popunjavanje koda te ?to za naredbe iz JavaScriptine standardne biblioteke (i one relativno opskurne, koje ?esto zaboravi? kako se koriste) daje kratku dokumentaciju. Nedostatak je ?to na mome ra?unalu treba dugo da se Eclipse pokrene i ?to se ponekad zaglavljuje.

VIM
VIM (od VI Improved, pobolj?ani VI, jer je VI, Visual Interface, bio ?esto kori?teni tekstualni editor na ra?unalima 1980-ih) je tekstualni editor koji se dobije uz gotovo sve verzije Linuxa i sli?nih operativnih sustava (FreeBSD, MacOS...). Prva verzija je napravljena 1991. On je ne?to kao Notepad na Windowsu, osim ?to pru?a neke mogu?nosti korisne za programiranje, recimo, sintaksno bojanje koda (za to koristi brze algoritme koji su uglavnom to?ni, ali nekada nisu, ?to pomalo ?ivcira), nadopunjavanje djelomi?no napisane naredbe (druk?iji algoritam nego Eclipse, uglavnom daje lo?ije rezultate), brzi odlazak na odre?enu liniju (korisno kada compiler javi da je gre?ka u odre?enoj liniji), prikaz linija koda, i tako dalje. Prednost nad Eclipseom je ?to se brzo otvara i ?to se na dana?njim ra?unalima nikad ne zaglavljuje, ?to je osobito va?no kad ?elim napraviti neku izmjenu na brzinu (da vidim kako ?e internetski preglednik na nju reagirati). Dodatna prednost, iako to meni nije bilo va?no, je ?to se mo?e koristiti dok na ra?unalu nije pokrenuto nikakvo grafi?ko su?elje, ?to je va?no ukoliko radimo s udaljenog ra?unala na serveru s kojim smo spojeni preko SSH-a (kada mo?emo koristiti samo tekstualno su?elje sli?no DOS-u). Naravno, mnoge su zna?ajke VIM-a (uklju?uju?i i alatnu traku i izbornu traku, da ne mora? pamtiti kako razne opcije pokrenuti preko tipkovnice) tada nedostupne. Uz Ubuntu Linux dobije se smanjena verzija VIM-a koja ne podr?ava mnoge korisne stvari (recimo, sintaksno bojanje koda, da se razli?ite vrste rije?i u programskom jeziku oboje razli?itom bojom), a uz Oracle Linux dobije se zastarjela verzija (koja, recimo, krivo oboji vi?elinijske stringove u JavaScriptu). No, to se mo?e rije?iti tako da se s interneta skine izvorni kod novije verzije i da se compilira.

GIMP
GIMP (GNU Image Manipulation Program) je program za ure?ivanje rasterske grafike koji se dobije uz ve?inu verzija Linuxa. Na Oracle Linux mora se zasebno instalirati, no radi uz samo manje probleme (recimo, ru?i se ako ga poku?amo postaviti u Single Window Mode). GIMP je, tako re?i, Linuxov Paint. Ustvari, podr?ava on i mnoge korisne stvari koje Paint (barem starije verzije, dugo nisam koristio Paint pa ne znam kako novije verzije) ne podr?ava, kao ?to su slojevi (layers) i prozirnost (transparency) dijelova slike. Ipak je znatno manje mo?an (ali time i lak?i za kori?tenje) od PhotoShopa. Prva verzija GIMP-a izdana je 1996. godine.

Inkscape
Inkscape je Linuxov program za ure?ivanje vektorske grafike. Prva verzija izdana je 2003. godine. Dok je GIMP primarno namijenjen za ure?ivanje slika u rasterskim formatima kao ?to su PNG, BMP i JPG, gdje se za (jako pojednostavljujem) svaki piksel nalazi informacija koje je boje, Inkscape slu?i za ure?ivanje slika u vektorskim formatima kao ?to je SVG, gdje se slika ne opisuje pojedinim pikselima nego oblicima kao ?to su crte odre?ene debljine i boje, poligoni, pravokutnici, krugovi, elipse, Bezierove krivulje, i tako dalje. Donekle sli?nu funkcionalnost ima Microsoft Office Publisher (no on ne podr?ava SVG format, koji meni treba, a nije ni besplatan) ili Corel Draw (on podr?ava SVG, ali nije besplatan, a i relativno je te?ak za kori?tenje).

Firefox
Firefox je internetski preglednik koji se dobije uz Oracle Linux i jedini je internetski preglednik koji radi prihvatljivo na Oracle Linuxu. Uz Oracle Linux jo? se dobije i Konqueror 4.14.8 (prastara verzija iz 2008. godine, doba Internet Explorera 7, i nema o?itog na?ina da se instalira nova), koji je prakti?ki beskoristan za dana?nji internet (rijetko koja se dana?nja internetska stranica prikazuje ispravno u njemu), i uz njega se ne dobivaju nikakvi alati za programiranje. Danas i najmanje informati?ki pismeni ljudi znaju ?to je to Firefox, Firefox i Chrome danas su najpopularniji internetski preglednici. Uz Firefox dobivaju se alati za programiranje: debugger za JavaScript, inspektor CSS-a, alati kojima se mo?e aproksimirati kako ?e web-stranica izgledati na raznim mobitelima (naravno, kako je ve?ina mobilnih internetskih preglednika bazirana na Chromu, a ne na Firefoxu, rezultati nisu pretjerano to?ni), inspektori AJAX-a i tako dalje. Alati za programiranje koji se dobiju uz internetske preglednike su primarno post-hoc, oni ne poma?u pri izradi web-aplikacije ili web-stranice, ali poma?u dijagnosticirati problem kad se dogodi. Postoje razni dodaci za IDE-jeve koji su namijenjeni za to da daju iskustvo pisanja programa u JavaScriptu sli?no kao pisanju programa u drugim popularnim programskim jezicima tako ?to povezuju Firefox ili Chrome i IDE, no njih je na Oracle Linuxu te?ko namjestiti.

Prettier
Prettier je formater za kôd, program koji se brine da kôd na programskom jeziku dobro izgleda ?to se ti?e uvlaka, prelaska u nove redove, i sli?ne stvari koje ne mijenjaju zna?enje koda. Jedan je od rijetkih takvih programa koji mo?e formatirati JavaScript, HTML i CSS kad su mije?ani u istoj datoteci, kao ?to je datoteka PicoBlaze.html. Po meni, on ne daje ba? lijepe rezultate, no takve tvrdnje ve? spadaju u subjektivni dio programiranja.

ClangFormat
ClangFormat je formater za kôd koji se dobije uz CLANG compiler za C, C++ i Objective-C. Mo?e ga se koristiti s mnogim programskim jezicima, u stvari, uspio sam ga namjestiti da formatira i kôd pisan na mom programskom jeziku, AEC-u (iako ima nekih problema s mojim programskim jezikom, recimo, nema o?itog na?ina da mu se objasni da je := operator pridru?ivanja u mom programskom jeziku, a ne oznaka za label plus operator =, no tokenizer za moj programski jezik ignorira razmake koje on stavlja izme?u : i =). Po meni, on daje lijepe rezultate za JavaScript. Mana mu je ?to ne mo?e formatirati HTML i CSS niti JavaScript spremljen u HTML datoteci.
LGTM
LGTM (Looks Good To Me) je besplatan internetski servis koji na svojim serverima na zahtijev pokre?e razne stati?ke analizere da analiziraju kôd pisan u raznim programskim jezicima pohranjen na GitHubu i sli?nim servisima. Stati?ki analizer je program koji poku?ava na?i gre?ke u drugim programima, a da ih ne pokrene. To je razli?ito od debuggera, programa koji poma?e dijagnosticirati gre?ku koja se dogodi kad se program pokrene pod njegovim nadzorom. Stati?ki analizeri osobito su korisni za popustljive jezike kao ?to je JavaScript. U JavaScriptu, recimo, ako krivo napi?emo ime varijable, compiler ne?e javiti gre?ku, nego ?e se program izvr?avati bez upozorenja sve dok ne do?e do mjesta u programu gdje se nalazi takva pogre?ka (ako smo u strogom na?inu rada, strict mode), ili ?ak i dalje (ako smo izvan strogo na?ina rada, compiler za JavaScript ?e na tom mjestu deklarirati novu varijablu s imenom jednakim tome krivo napisanom imenu). Isto tako, ako krivo napi?emo ime neke funkcije, program ?e se vrtjeti sve dok ne do?e do te to?ke, i tek onda javiti pogre?ku, tako da nam tako ne?to pri brzinskom testiranju lako mo?e promaknuti. U ve?ini drugih programskih jezika takve vrste gre?aka ne mogu promaknuti: compiler ?e javiti o takvim gre?kama prije no ?to se program uop?e pokrene. Za JavaScript, ako to ?elimo, moramo koristiti stati?ki analizer.

Mane dana?njih simulatora PicoBlazea
Mnogi bi smatrali ?injenicu da su danas naj?e??e kori?teni simulatori PicoBlazea zatvorenog koda njihovom velikom manom. PicoBlaze mekani procesor (procesor koji se mo?e u cijelosti implementirati FPGA-ovima) jest otvorenog koda. Me?utim, on se mo?e compilirati samo Xilinxovim compilerom za VHDL, koji je zatvorenog koda. Najnapredniji compiler za VHDL koji je otvorenog koda danas je, bez sumnja, GHDL, ali njegova kompatibilnost sa Xilinxovim compilerom je slaba. Zato danas naj?e??e kori?teni simulatori PicoBlazea, koji ciljaju na to da ga simuliraju u VHDL-ovske detalje, sadr?e elemente zatvorenog koda. Dakle, to su programi za koje je ilegalno provjeravati da nisu zlonamjerni. Upitno je mogu li nam ekonomski faktori i ameri?ki pravni sustav garantirati da Xilinxovi programi nisu Trojanski konji. ?esto se postavlja pitanje jesu li programi zatvorenog koda odraz prava na privatnost softwareskih firmi, ili su odraz nedostatka transparentnosti? Gdje je crta izme?u privatnosti i nedostatka transparentnosti? ?to ljudi pi?u u privatnim pismima i privatnim elektroni?kim pismima ne ti?e se nikoga drugog. Ali programi koji se javno objavljuju ipak se ti?u svih nas, zar ne? Isto tako, ?to se doga?a u klaonicama ili privatnim zatvorima nije samo stvar ljudi koji tamo rade, nego svih nas, zar ne? Stoga ne bi trebali postojati zakoni koji sprje?avaju da se te stvari provjeravaju.
Po autoru ovog teksta, jedna od glavnih mana dana?njih simulatora PicoBlazea je upravo to ?to oni ciljaju na simuliranje PicoBlazea (i druge mekane procesore) u VHDL-ovske detalje. Da bi to napravili, simulatori moraju biti programi od po stotine ili ?ak i tisu?e MB-a. Ako poku?amo s interneta skinuti i na disk pohraniti na stotine MB-a ili nekoliko GB-a podataka, gotovo sigurno ?emo naletjeti na neke neo?ekivane probleme (pucanje internetske veze zbog kojeg moramo krenuti ispo?etka, gre?ke u datote?nom sustavu nastale naglim ga?enjem ra?unala koje ne bivaju o?ite dok ne poku?amo spremiti neku ogromnu datoteku...).
Glavna mana dana?njih simulatora PicoBlazea je to ?to ih se na ra?unalo mora instalirati da bi funkcionirali. Nije ih mogu?e pokrenuti u internetskom pregledniku ili skinuti ZIP-arhivu i otpakirati je gdje ?elimo. To je osobit problem na Linuxu iz dva razloga. Prvo, instaliranje programa obi?no zauzima mjesta na SSD-u (gdje je spremljen Linux i sistemski direktorij gdje se obi?no spremaju instalirani programi, /usr/bin), a ne na HDD-u (na kojem obi?no ima daleko vi?e slobodnog mjesta, i koji se ne tro?i kada na njega pi?emo ili bri?emo s njega). Jedan od na?ina da se to rije?i je postavljanje virtualne ma?ine ?iji se virtualni tvrdi disk nalazi na HDD-u, no to je dugotrajan i kompliciran posao, a i nezgodno je ?ekati da se pokrene jo? jedan Linux kad god nam treba neki program koji nam mo?da ?esto treba. Drugo, programeri koji nemaju iskustva s radom na Linuxu obi?no pretpostavljaju da postoji samo jedan, nekakav apstraktni, Linux. Simulatori PicoBlazea obi?no su testirani na Red Hat Linuxu, i programeri vjerojatno pretpostavljaju da, ako tamo radi, radit ?e na drugim verzijama Linuxa. No to vrijedi samo za najjednostavnije programe pisane u C-u ili Assembleru, ?ak ne ni za Hello World program pisan u C++-u. Istina je da ?e program koji radi na Red Hat Linuxu vjerojatno raditi bez problema na Oracle Linuxu, CentOS-u i Scientific Linuxu, a mo?da i na Fedori. No, ako ?elite pokrenuti program za Red Hat Linux na Ubuntu Linuxu, Debianu ili Mint Linuxu (danas naj?e??e kori?tene verzije Linuxa), puno sre?e s time. Vrijedi i obratno: programi za Debian rijetko kad se mogu jednostavno pokrenuti na Oracle Linuxu. Iako postoje programi za Linux koji izvrsno rade na mnogim verzijama Linuxa (Firefox, recimo, radi savr?eno na Ubuntu Linuxu, a na Oracle Linuxu samo ima problema s prikazom MP4 videa), da bi se to postiglo trebaju programeri koji poznaju Linux u najve?e detalje, a takvi su rijetki. Ve?inom se programi za Linux na mnogim verzijama Linuxa ne daju niti instalirati. I, zapravo, instalacija je nerijetko najve?i problem. Poku?aj da se na Oracle Linux instalira Chrome pomo?u RPM datoteke skinute s Googlea (namijenjene za Fedoru) dovodi do hrpe poruka o pogre?ci, a, ipak, izvr?na datoteka Chromiuma s AppSpota funkcionira uz manje probleme. Programi otvorenog koda, kao ?to su VIM, mogu funkcionirati na mnogim verzijama Linuxa tako ?to se oslanjaju na compilere i srodne alate prisutne na Linuxu za instalaciju. No, to za napredne PicoBlaze simulatore, kojima je barem dio koda zatvoren, nije opcija. Nema jednostavnog rje?enja za taj problem. Linux je otporniji na ra?unalne viruse od Windowsa dijelom i upravo zato ?to ne postoji samo jedan Linux, nego mnogo verzija Linuxa koje me?usobno nisu posve kompatibilne. Ako bismo napravili da programi za jednu vrstu Linuxa funkcioniraju na svim vrstama Linuxa, olak?ali bismo posao nekim programerima, ali jo? bismo vi?e olak?ali posao kriminalcima koji rade ra?unalne viruse. Kompatibilnost me?u ra?unalima mo?e se koristiti i za dobro i za zlo. Isto vrijedi i za biolo?ke viruse: Ako nema genetske raznolikosti, oni se znatno lak?e prenose. Neke su neko? veoma popularne sorte banana izumrle zbog virusne infekcije, jer su sve jedinke te sorte imale vi?e-manje iste gene za imunitet od virusa. ?im se dogodila mutacija da mo?e jednu zaraziti, mogao je zaraziti sve istim na?inom napadanja. Isto tako, ?i?mi?i i ljudi imaju veoma sli?an imunolo?ki sustav, i zato su virusi koji mogu napasti i ?i?mi?e i ljude relativno ?esti. Psi i ljudi imaju donekle razli?it imunosni sustav, i zato su virusi koji mogu napasti i ljude i pse relativno rijetki. Virusi koji mogu napasti i ptice i ljude vrlo su rijetki (pod svjetlosnim mikroskopom vidi se razlika izme?u leukocita sisavaca i leukocita ptica), a virusi koji mogu napasti i ljude i gmazove ne postoje.
Simulator PicoBlazea u JavaScriptu otvorenog je koda, to jest, kôd je dostupan javno na GitHubu (i, budu?i da je web-aplikacija, ne mo?e u?initi ni?ta lo?e ra?unalu ukoliko se pokrene u sigurnom internetskom pregledniku), velik je svega 196KB, i ne zahtijeva nikakve instalacije.

Struktura simulatora za PicoBlaze u JavaScriptu
Simulator PicoBlazea u JavaScriptu nema back-end (kôd koji se vrti na serveru), ve? se u cijelosti vrti u internetskom pregledniku. Njegov kôd podijeljen je u 7 datoteka, ukupno 3'550 redaka: 
    1. PicoBlaze.html - sadr?i HTML kôd i CSS kôd te JavaScript vezan za postavljanje izgleda web-aplikacije, sintaksno bojanje asemblerskog koda, postavljanje simulatorske niti, komunikaciju izme?u tokenizera, parsera, pretprocesora i asemblera (u svijetu compilera to se zove driver) te za dohva?anje primjera asemblerskog koda s autorovoga GitHub profila. Naknadno je dodana mogu?nost dodavanja to?aka prekida (breakpoints), mogu?nost skidanja heksadekadske datoteke koju proizvodi assembler (koja se uz pomo? alata za programiranje PicoBlazea veoma lako pretvori u binarni format koji treba PicoBlazeu) te zoran prikaz sedam-segmentnih pokaznika (seven-segment display) i prekida?a (switches, ovdje reagiraju na pritisak mi?a) pomo?u SVG-a generiranog u JavaScriptu. Skidanje heksadekadske datoteke radi se preko standardnih JavaScript klasa HTMLAnchorElement (svojstvo download i metoda za stvaranje eventa iz JavaScripta click), Uint8Array, URL i Blob, bilo je relativno komplicirano za napraviti. To?ke prekida rade se tako da se brojevi linija koda nalaze u zasebnim HTML elementima <div> koje generira JavaScript i ti elementi osim brojeva linija koda sadr?avaju i ikone koje predstavljaju to?ke prekida koje su po defaultu nevidljive. Objekt machineCode ?uva i podatke o linijama koda iz kojih dolaze naredbe. Datoteka PicoBlaze.html ima 1'320 redaka koda. CSS koji se koristi je relativno primitivan (recimo, nema medijskih upita), za pozicioniranje elemenata na ekranu uglavnom se koristi JavaScript. Iskreno, ne da mi se u?iti napredni CSS kad izgleda da mogu i bez toga. U CSS-u se koriste varijable, no dodan je i fallback za internetske preglednike koji ne podr?avaju CSS-ove varijable (njih ne podr?ava, koliko je meni poznato, niti jedan internetski preglednik koji se mo?e vrtjeti na Windows XP, zastarjelom, ali na zastarjelim ra?unalima u obrazovnim ustanovama jo? uvijek popularnom operativnom sustavu). Velik dio HTML-a (sve tablice) tako?er se generira u JavaScriptu, uglavnom pomo?u JavaScriptinih vi?elinijskih stringova i JavaScriptine naredbe innerHTML. Razni internetski preglednici rade probleme ako se tako poku?aju generirati SVG elementi (u JavaScriptu se generiraju SVG elementi koji predstavljaju sedam-segmentne pokaznike, prekida?e i LED-ice), pa sam za svaki slu?aj to radio JavaScriptinim naredbama createElementNS, setAttribute i appendChild.
    2. TreeNode.js - sadr?i JavaScript klasu pod nazivom TreeNode, koja sadr?i metode vezane za evaluaciju parsiranih aritmeti?kih izraza, metodu za ispis LISP-ovih izraza radi debugiranja parsera, te metode za pretragu struktura koje radi pretprocesor. Ta datoteka ima 100 redaka koda.
    3. assembler.js - radi semanti?ku provjeru asemblerskog koda (recimo, je li prvi argument naredbe load uistinu registar) pomo?u strukture koje radi parser te spaja strukturu koju radi parser i strukture koje radi pretprocesor u strojni kod u heksadekadskom obliku. Tako?er radi neke sintaksne provjere koje parser ne radi, recimo, nalazi li se izme?u dva argumenta naredbe load zarez. Ima 1'050 redaka koda. Pretvoriti strojni kod u heksadecimalnom obliku u binarni oblik (kakav razumije PicoBlaze) nije lagano u JavaScriptu, jer najmanja jedinica memorije koja se u JavaScriptu mo?e adresirati jest byte, 8 bitova, a svaka naredba u strojnom kodu PicoBlazea je 18 bitova, ?to nije cijeli broj byteova. Za razliku od ostalih potprograma, assembler.js i simulator.js svoje rezultate ne vra?aju kao povratnu vrijednost funkcije, nego ih pi?u u globalne varijable.
    4. parser.js - Parser (od latinskog pars, dio) je dio compilera (u ovom slu?aju, compilera za asemblerski jezik) koji drugim dijelovima compilera ka?e koja je rije? u programskom jeziku gramati?ki povezana s kojom drugoj rije?i. To radi tako ?to radi strukturu zvanu AST, abstract syntax tree, apstraktno sintaksno stablo. Kao obja?njenje za?to je to potrebno, uzmite u obzir sljede?u re?enicu iz Cezarovog De Bello Gallico (koja je bila na ?upanijskom natjecanju iz latinskog jezika 2016. godine, 6. svitak, 24. poglavlje): Ea, quae fertilissima totius Germaniae sunt, loca Graecis aliquibus nota fama esse loquuntur. S kojom je rije?i povezana rije? nota (poznata)? Ako znate samo malo latinskog, vjerojatno biste pomislili da je rije? nota gramati?ki povezana s fama (slava, glasina), da je to pleonazam i da rije? nota treba zanemariti. No, to je krivo. Rije? nota povezana je s rije?ju loca (mjesta, lokacije). Rije? fama je u ablativu jednine (ablativ je latinski pade? koji odgovara hrvatskom lokativu, instrumentalu te genitivu u zna?enju iz koga ili iz ?ega), a igrom slu?aja na latinskom jeziku akuzativ mno?ine u drugoj deklinaciji u srednjem rodu i ablativ jednine prve deklinacije imaju isti nastavak  (to jest, isti su u pisanom latinskom ako ne ozna?avamo naglaske, ina?e je a u nastavku u fama dugo, a u nota kratko), re?enica zna?i: Ka?u (loquuntur) da su (esse) ona (ea) mjesta, koja (quae) su (sunt) najplodnija (fertilissima) u cijeloj (totius) Germaniji, nekim (aliqubus) Grcima (Graecis) glasinom poznata. Glagol biti je jednom u prezentu (sunt), a jednom u infinitivu (esse), zbog jednog neva?nog detalja iz latinske sintakse koji se zove akuzativ s infinitivom. Glagol loquuntur je takozvani deponentni glagol, morfolo?ki je pasivan, a semanti?ki aktivan (zato je nastavak -untur, a ne -unt). Pridjev totus (cijeli) ima nepravilni genitiv jednine na -ius (totius), kao jo? nekolicina latinskih pridjeva. Za slu?ajeve kad se takve stvari dogode u programskom jeziku, parser bi spojio rije?i nota i loca u jedan ?vor sintaksnog stabla. Ta mi je re?enica ostala u sje?anju jer mi je profesor pri?ao da je ispravljao test neke u?enice koja je tu re?enicu krivo prevela ne?to kao Najplodnija Njemica..., no to bi se ve? te?ko dalo objasniti kao rezultat pogre?nog parsiranja. Ta su se najplodnija mjesta u Germaniji nalazila oko nekakve ?ume. Kasnije je u tom tekstu bilo Ea (tamo = u toj ?umi) nascuntur (ra?aju se) alces (sjeverni jeleni)..., a ona je to navodno prevela s Ona ra?a sjeverne jelene..., a to opet nije stvar krivog parsiranja kad po morfologiji vidimo da je nascuntur pasiv i vidimo da je u mno?ini. Parser za asemblerski jezik bio je mnogo lak?i za napisati nego parser za AEC, moj programski jezik. Parser za moj programski jezik2 duga?ak je 950 redaka, dok datoteka parser.js sadr?i 125 redaka. Zapravo, jedino ?to je nu?no parsirati u asembleru za PicoBlaze jesu aritmeti?ki izrazi. Algoritam napisan u datoteci parser.js ide ovako:
        1. Prona?i parove otvorenih i zatvorenih zagrada u nizu koji ti je dao tokenizer. Parovi otvorenih i zatvorenih zagrada nalaze se, naime, u aritmeti?kim izrazima te kao oznaka da je ono ?to se nalazi u registru pokaziva?. Kada na?e? neki par zagrada, prebaci ono izme?u zagrada u novi niz, obri?i to iz originalnog niza, i pokreni rekurziju s novim nizom kao argumentom. Ako zagrade nisu dobro zatvorene, javi poruku o pogre?ci. U parseru za svoj programski jezik zadao sam da se i zagrade obri?u iz sintaksnog stabla. U asemblerskom jeziku za PicoBlaze to ne bi imalo smisla, budu?i da zagrade imaju zna?enje da je u registru pokaziva?, pa bih si time samo zakomplicirao asembler. Potprogram u parser.js zato za svaki par zagrada ume?e ?vor s tekstom (), i njegova su djeca (polje children iz klase TreeNode) niz koji vrati rekurzija.
        2. Prolazi kroz niz koji ti je dao tokenizer i za svaku rije? provjeri nalazi li se na popisu mnemonika (tako se tradicionalno zovu glagoli u asemblerskom jeziku3) ili pretprocesorskih direktiva. Ti se popisi nalaze u datoteci PicoBlaze.html. Ako se rije? na koju si upravo nai?ao nalazi jednom od tih popisa, a nije da je rije? jednaka enable ili disable i da je du?ina niza jednaka jedinici (jer enable i disable, osim ?to mogu biti glagoli, mogu biti i, recimo to tako, prilozi glagola returni), premjesti sve izme?u tog glagola i znaka za novi red (isklju?ivo) u novi niz, pokreni rekurziju i proglasi ono ?to rekurzija vrati djecom ?vora u kojem je taj glagol. To funkcionira zato ?to svaka re?enica u asemblerskom jeziku po?inje s glagolom te, osim u aritmeti?kim izrazima, ne postoji lingvisti?ka rekurzija, to jest, u asemblerskom jeziku ne postoje slo?ene re?enice. Kao zanimljivost, neki lingvisti (ustvari, danas mo?da samo Daniel Everett) tvrde da je pirahanski jezik, slabo dokumentirani jezik iz Brazila, takav.
        3. Parsiraj aritmeti?ke izraze. Prvo se baktaj s unarnim operatorima, njih se detektira kao tokeni + (plus) i - (minus) ispred kojih se ne nalazi ni?ta (prvi token u nizu), ili se ispred njih nalaze tokeni , (zarez), ( (otvorena zagrada) ili token koji sadr?i znak za novi red. Zatim konstruiraj lambda-funkciju parseBinaryOperators koja prima niz operatora te prolazi originalni niz u potrazi za njima, i, kada ih na?e, njihove susjedne tokene progla?ava njihovom djecom i bri?e iz niza. Ta se lambda-funkcija prvo poziva za niz samo s operatorom potenciranja, ^, jer on ima najve?i prioritet, zatim se poziva za operatore mno?enja i dijeljenja, * i /, te kona?no za zbrajanje i oduzimanje, + i -. Parser za moj programski jezik mora paziti na razliku izme?u lijevo-asocijativnih operatora i desno-asocijativnih operatora. No, budu?i da su svi aritmeti?ki operatori lijevo-asocijativni, to ovdje nije potrebno.
Na kraju bismo trebali dobiti asemblerski kod u obliku LISP-ovog S-izraza, koje JavaScript u  datoteci PicoBlaze.html za potrebe tra?enja gre?aka u asembleru ispisuje na preglednikovu konzolu JavaScriptinom naredbom console.log. Profesor Ivan Aleksi predlagao mi je da ne ugradim podr?ku za aritmeti?ke izraze u svoj asembler i da ni ne parsiram asemblerski kod nego da ga pretvorim u dvodimenzionalno polje stringova, gdje svaki redak iz asemblerskog koda predstavlja jedno jednodimenzionalno polje u tom dvodimenzionalnom polju, da prvi string u tom jednodimenzionalnom polju bude potencijalni naziv labela ili prazan string, da drugi string bude glagol, i tako dalje. Ja mislim da je raditi na taj na?in jo? kompliciranije.
    5. preprocessor.js - Prima strukturu koju pravi parser i odre?uje adrese labelsa (labelsi su oznake na koje je mogu?e sko?iti naredbom goto, ili, kako se u assemblerskom jeziku zove ta naredba, jump). To je znatno lak?e napraviti za PicoBlaze nego za Intelove i AMD-ove (x86) procesore, jer su za PicoBlaze sve naredbe u strojnom jeziku jednake du?ine (18 bitova), pa mo?emo svaki puta kada nai?emo na mnemoniku u AST-u pove?ati trenutnu adresu za jedan. Za x86, taj algoritam ne bi bio to?an, jer, recimo, asemblerska naredba int 0x3 (u doba DOS-a slu?ila za pozivanje debuggera) ima 8 bitova (u heksadekadskom formatu je cc), dok int 0x20 (u doba prvih verzija DOS-a slu?ila za zatvaranje programa) ima 16 bitova (u heksadekadskom formatu je 20cd), a mov rax,[3*rbx+7] ima 40 bitova (heksadekadski 8b485b440007). Potprogram preprocessor.js tako?er izvr?ava i sprema rezultate direktiva constant i namereg (za preimenovanje registara u smislene nazive) u Map (klasa ?iji objekti sadr?avaju parove klju?-vrijednost, dostupna u standardnoj biblioteci JavaScripta od vremena Internet Explorera 11). Primijetite da se pretprocesor u kontekstu asemblera jako razlikuje od pretprocesora u kontekstu compilera. U compilerima, pretprocesor se pokre?e jo? prije tokenizera. U asemblerima, pretprocesor se pokre?e nakon parsera, ali prije jezgre asemblera. U mnogim je asemblerima pretprocesor Turing-potpun (Turing-complete), ?to je rijedak slu?aj u vi?im programskim jezicima (koliko znam, to jo? vrijedi jedino za PERL). Zapravo, to se u vi?im programskim jezicima smatra lo?im jer programske jezike ne treba mo?i parsirati samo compiler za taj programski jezik, nego i drugi alati za programiranje. Jedna od ?estih kritika PERL-a je upravo Only PERL can parse PERL.. Potprogram preprocessor.js ima 140 redaka.
    6. simulator.js - Taj se potprogram pokre?e u zasebnoj dretvi kad pritisnemo tipku play ili fast forward, a u istoj dretvi ako pritisnemo tipku single step. On ?ita strojni kod u heksadekadskom obliku koji je u globalni objekt machineCode (deklariran u PicoBlaze.html) upisao potprogram assembler.js, te simulira PicoBlaze pi?u?i i ?itaju?i iz memorije (globalni objekt memory tipa Uint8Array deklariran u PicoBlaze.html), registara (niz, zvan registers, od dva globalna objekta tipa  Uint8Array deklarirana u  PicoBlaze.html, te globalna varijabla PC, program counter, koja pokazuje na naredbu u memoriji koja se trenutno izvr?ava) i zastavica (gloablnih nizova flagC, flagZ te globalnih varijabli flagIE i regbank), pi?u?i u izlaze (globalni objekt output), ?itaju?i, koriste?i DOM, ulaze iz one tablice s 256 HTML-ovih input-a, te upravljaju?i stogom callStack. Naknadno je dodano da za svaku naredbu provjerava je li na njoj breakpoint. Potprogram simulator.js ima 690 redaka. Razmi?ljao sam isprva o tome da jezgru simulatora napi?em u svom programskom jeziku, a ne u JavaScriptu (preko svog compilera koji cilja WebAssembly, standardizirani JavaScript bytecode), no odlu?io sam da to ipak ne radim tako. Naime, compiler za moj programski jezik kompatibilan je samo s najnovijim internetskim preglednicima, ne mo?e ciljati niti Microsoft Edge, a, rebus sic stantibus, danas tako ne?to nije opcija ako ?elimo da nam web-aplikacija bude popularna. Uostalom, sigurno bih naletjeo na neke probleme vezane za komunikaciju potprograma pisanih u JavaScriptu i potprograma pisanih u mom programskom jeziku, tako da je upitno bih li se manje namu?io pi?u?i taj simulator u svom programskom jeziku.
    7. tokenizer.js - Tokenizer je dio compilera koji ka?e drugim dijelovima compilera gdje zavr?ava koja rije?, a gdje po?inje druga, u programskom jeziku. Rije?i u programskom jeziku zovu se tokeni (engleski token izvan svijeta informatike zna?i oznaka). U programskim jezicima rije?i ne moraju nu?no biti odvojene razmacima, nego ve?ina programskih jezika koristi malo kompleksnije mehanizme odvajanja rije?i. Velika ve?ina programskih jezika koristi mehanizam odvajanja rije?i koji podsje?a na japansko pismo. Naime, japansko pismo ima tri skupa znakova: hiragana, katakana i kand?i. Kand?i su kineski znakovi i koriste se za pisanje korijena rije?i. Katakana je slogovno pismo koje se koristi za pisanje korijena stranih rije?i ili onomatopeja. Hiragana je slogovno pismo koji se koristi za pisanje gramati?kih afiksa (prefiksa i sufiksa). Ve?ina gramati?kih afikasa u japanskom su sufiksi, tako da, kada do?emo do nekog hiraganskog znaka, znamo da je to nastavak prethodne rije?i, a ne nova rije?. S druge strane, ako nai?emo na kineski znak ili katakanski znak nakon niza hiraganskih znakova, to je naj?e??e nova rije?. Sli?an postupak za odvajanje rije?i postoji u ve?ini programskih jezika. Potprogram tokenizer.js ima 95 linija. Tokenizer za moj programski jezik4, za usporedbu, ima 260 linija. Jedna od glavnih razlika izme?u algoritma koji sam koristio za svoj programski jezik i algoritma koji sam koristio za PicoBlaze je ta ?to u PicoBlazeu nisam poku?avao zapisivati broj stupca (column number), jer su svi reci u asemblerskom jeziku kratki, pa podaci o stupcima gdje po?inje koji token ne?e previ?e pomo?i u tra?enju pogre?ke. Tako?er, tokenizer za moj programski jezik ne smatra znak za novi red tokenom, dok tokenizer za PicoBlazeov asemblerski jezik smatra. Tokenizer za moj programski jezik mora se brinuti o escape-sequence znakovima u stringovima (\"...), dok tokenizer za PicoBlazeov asembler ne mora. U compileru za moj programski jezik tokenizer zamjenjuje tokene poput 'a' odgovaraju?im ASCII vrijednostima (?to mo?da i nije bila dobra ideja, jer poruke o pogre?kama tipa unexpected token zbog toga mogu biti nejasne), u asembleru za PicoBlaze to radi potprogram TreeNode.js.
Osim tih datoteka, u GitHub repozitoriju nalaze se slike napravljene u GIMP-u (Linuxov Paint) i Inkscapeu (Linuxov Publisher) te primjeri programa za PicoBlaze koje je mogu?e dohvatiti klikaju?i na examplese. Slike koje predstavljaju play, pause, stop, fast forward i single step su u SVG formatu i ure?ivane u Inkscapeu. Ikona za Assembler Test u GIF je formatu i ure?ivana u GIMP-u. Ikone za primjer Hexadecimal Counter te ikona koja predstavlja to?ku prekida (breakpoint) isto su ure?ivane u GIMP-u, ali spremljene su u PNG formatu, jer ih PNG format bolje sa?ima nego GIF format. Pozadina je fotografija PicoBlaze ra?unala koju je profesor Ivan Aleksi uklju?io u svoju prezentaciju, posvijetljena u GIMP-u i spremljena kao GIF.

Primjeri programa za PicoBlaze
Web-aplikacija nudi tri primjera programa za PicoBlaze. Prvi se zove Fibonacci Sequence. On ispisuje Fibonaccijeve brojeve koji stanu u jedan byte (koliko su veliki PicoBlazeovi registri, svih 32), dakle, manje od 256. One koje se mogu prikazati u BCD (binary coded decimal, tako se u 8 bitova mogu prikazati brojevi manji od 100) formatu tako i ispisuje, a, one koji se ne mogu, ispisuje u heksadekadskom formatu. Tako?er koristi bitovne operacije da bi izbrojao koliko ima jedinica u binarnom zapisu svakog od tih brojeva. Kad zavr?i, javlja da je zavr?io naredbom return, ?to ne bi pro?lo na pravom PicoBlazeu. Da bi ispisao broj u novi red, on ispisuje na port sa sljede?om adresom, ?to na pravom PicoBlazeu isto ne bi pro?lo. Ima 116 redaka, uklju?uju?i brojne komentare. Program Gray Code koristi bitovne operacije da bi binarne brojeve pretvarao u i iz Grayevog koda. To je na?in kodiranja brojeva koji se ?esto koristi u digitalnoj elektronici, ima svojstvo da se susjedni brojevi razlikuju samo u jednoj binarnoj znamenki. Recimo, brojanje od 0 do 10 u binarnom sustavu ide (promijenjene znamenke u susjednim brojevima su boldirane, a lijeve nule, koje nije potrebno pisati, u zagradama su): (000)0, (000)1, (00)10, (00)11, (0)100, (0)101, (0)110, (0)111, 1000, 1001, 1010. U Grayevom kodu ti brojevi su: (000)0, (000)1, (00)11, (00)10, (0)110, (0)111, (0)101, (0)100, 1100, 1101, 1111. To svojstvo je korisno jer ne moramo ra?unati na to da su ra?unala koja izmjenjuju poruke potpuno sinkronizirana, da jedno ra?unalo po?ne ?itati broj sa ?ice tek kad ga je drugo ra?unalo ve? dovr?ilo mijenjati. To je osobito bilo va?no za ra?unala iz 1940-ih, na kojima implementiranje protokola sinkronizacije (Manchestersko kodiranje...) nije bilo jednostavno ili ?ak ni mogu?e. Program Gray Code koristi algoritam opisan na engleskoj Wikipediji, te se vrti u beskona?noj petlji ?itaju?i s ulaza. Ima 25 redaka. Program Assembler Test je besmislen program koji koristi sve naredbe koje podr?ava assembler za PicoBlaze, da bude lak?e testirati assembler. Ako se pokrene u simulatoru, vrti se u beskona?noj petlji. Ima 83 reda. Naknadno su dodani primjeri Binary to Decimal i Hexadecimal Counter. Binary to Decimal postavljen je kao prvi primjer s lijeva. On ?ita 8-bitni binarni broj unesen pomo?u onih SVG-ovskih prekida?a, pretvara ga u decimalni broj i rezultat prikazuje na sedam-segmentnim pokaznicima, te se vrti u beskona?noj petlji. Pretvaranje binarnog broja u decimalni radi se algoritmom za pretvaranje binarnog broja u BCD, uz izmjenu da pazi nalazi se broj izme?u 0 i 99, izme?u 100 i 199 ili je vi?e od 200 (8-bitni binarni brojevi mogu biti najvi?e 255). Uz to on zapo?ljava i LED-ice tako ?to na njima prikazuje broj pretvoren u Grayev kod. Hexadecimal Counter besmislen je program koji pali i gasi LED-ice te prikazuje heksadecimalne brojeve na 7-segmentnim pokaznicima.

Mane simuliranja PicoBlazea u JavaScriptu
Naravno, taj simulator PicoBlazea ?to sam ga napravio u JavaScriptu ima i svoje nedostatke naspram fully-featured simulatora. Prvo, on ne poku?ava interpretirati VHDL, tako da ne mo?e simulirati PicoBlazeove s modificiranim VHDL kodom (osim ako ne promijenimo JavaScript, ali opet nam to ne?e pomo?i da na?emo gre?ke u VHDL kodu). Drugo, grafi?ko su?elje mu je mnogo manje efektivno nego su?elje koje pru?aju naj?e??e kori?teni simulatori PicoBlazea. Dobro je poznato da je u web-aplikacijama te?ko napraviti dobro korisni?ko su?elje. Profesor Ivan Aleksi mi je predlagao da probam koristiti neki JavaScript radni okvir (framework) za pravljenje korisni?kih su?elja, kao ?to je ReactJS, no za njih treba vremena da se nau?e, a i pitanje je koliko uistinu poma?u. Tre?a je mana ?to je nemogu?e napraviti realisti?ni tajming. Jedna od prednosti PicoBlazea za kori?tenje u ugra?enim sustavima, gdje trebaju mala ra?unala, jest upravo to ?to je lagano odrediti koliko ?e se dugo neki komad koda izvr?avati ako znamo na koliko MHz-a radi (PicoBlaze mo?e raditi na frekvenciji do oko 130 MHz), svaka instrukcija traje to?no dva takta. U JavaScriptu je to nemogu?e simulirati, jer JavaScript, na primjer, ima sakupljanje sme?a koje se pokre?e (?to se JavaScriptskog programa ti?e) nedeterministi?ki. Uz to, na danas prosje?nom ra?unalu taj moj simulator mo?e izvr?iti oko 20 instrukcija po sekundi (u fast-forwardu u Firefoxu, pregledniku koji najbr?e izvr?ava JavaScript), daleko manje od 75'000'000 operacija u sekundi koji bi bili potrebni za realisti?ni tajming. Jedan ?ovjek na internetskom forumu tvrdi da ga vjerojatno najvi?e usporava to ?to se simulacijska dretva prekine kad se izvr?i jedna instrukcija, a ponovno postavlja kad se treba izvr?iti nova, a na postavljanje i uni?tavanje JavaScriptine dretve tro?e se mnogi ra?unalni resursi5. Dakle, da bismo postigli realisti?an tajming, morali bismo posve preurediti simulator, a vjerojatno i napisati ga u drugom programskom jeziku (a puno sre?e da ga onda pokrenete u internetskom pregledniku). Iako moj simulator nije dostatan za neke potrebe, smatram da je dostatan za potrebe studenata i da ?e ih spasiti hasslea instalacije naprednijih simulatora.

Zahvale
Posebno zahvaljujem profesoru Ivanu Aleksiju ?to me potakao da ovo napravim i ?to je sakupio informacije na internetu potrebne za to. Zahvaljujem i programerima koji su napravili internetski servis LGTM, stati?ki analizer za JavaScript koji me je upozorio na neke gre?ke koje sam napravio. JavaScript je relativno lo? programski jezik i takvi su alati korisni.
