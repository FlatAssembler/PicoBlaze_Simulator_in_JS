Simulator PicoBlaze ra?unala u JavaScriptu

Autor: Teo Samar?ija

SA?ETAK: Autor ovog teksta bio je frustriran nedostacima postoje?ih simulatora malog ra?unala PicoBlaze, te je napravio znatno druk?iji simulator PicoBlazea u programskom jeziku JavaScript. Simulator koji je autor napravio mo?e se pokrenuti u modernim internetskim preglednicima1. U tekstu slijede detalji o tome kako je autor napravio taj svoj simulator te koje su prednosti i mane tog simulatora u usporedbi s ve? postoje?im simulatorima. Nisu kori?teni nikakvi radni okviri (frameworksi), kod je pisan u VIM-u, za ure?ivanje slika kori?teni su GIMP i Inkscape, za tra?enje pogre?aka u programu kori?teni su alati za programiranje koji se dobiju uz Firefox i internetski servis LGTM. Za formatiranje koda kori?teni su Prettier (za HTML i CSS) i ClangFormat (za JavaScript).

Uvod
PicoBlaze (od latinskog piccus, rupica na igli, u prenesenom zna?enju ne?to maleno, i engleskog blaze, plamen) je malo ra?unalo koji proizvodi tvrtka Xilinx. Koristi se u ugra?enim sustavima, te kao primjer jednostavnog ra?unala na kolegiju Arhitektura ra?unala na FERIT-u. Njegov je procesor dizajniran tako da se u cijelosti mo?e implementirati programibilnim elektroni?kim sklopovima (FPGA-ovima...), te je pisan u programskom jeziku VHDL. PicoBlazeov procesor jako se razlikuje od procesora kori?tenih u stolnim ra?unalima (koje proizvode tvrtke Intel i AMD) i procesora u mobilnim telefonima i tabletima (uglavnom ARM-ovi procesori), i potreban nam je simulator da bismo pokrenuli programe za njega na ra?unalu na kojem programiramo, radi testiranja ili tra?enja pogre?ke u programu. Simulator je program koji omogu?uje ra?unalu da se pretvara da je nekakvo druk?ije ra?unalo. Rije? simulator zna?i onaj koji kopira ili imitira, dolazi iz latinskog i prvi put se spominje u Ovidijevim Metamorfozama (11. poglavlje, 634. stih). Dolazi od simulare (pretvarati se), od similis (sli?an). PicoBlaze vjerojatno ne mo?e pokrenuti alate za programiranje (ili mo?da i mo?e, ali bi oni bili jako spori i neprakti?ni za kori?tenje - daleko gori od alata za programiranje mobitela koji se pokre?u na mobitelima), on bez kori?tenja pomo?nih ure?aja mo?e koristiti svega 0.25 KB memorije za spremanje podataka i 9 KB-a memorije za spremanje programa. Za simuliranje PicoBlazea naj?e??e se koriste FIDEX, koji proizvodi tvrtka Fautronix, ili Xilinx ISE, koji, naravno, proizvodi tvrtka Xilinx. Postoje legalne besplatne verzije tih programa koji se mogu skinuti s interneta, i te besplatne verzije podr?avaju vjerojatno sve ?to nekome treba, tako da cijena nije problem.

Mane dana?njih simulatora PicoBlazea
Mnogi bi smatrali ?injenicu da su danas naj?e??e kori?teni simulatori PicoBlazea zatvorenog koda njihovom velikom manom. PicoBlaze mekani procesor (procesor koji se mo?e u cijelosti implementirati FPGA-ovima) jest otvorenog koda. Me?utim, on se mo?e compilirati samo Xilinxovim compilerom za VHDL, koji je zatvorenog koda. Najnapredniji compiler za VHDL koji je otvorenog koda danas je, bez sumnja, GHDL, ali njegova kompatibilnost sa Xilinxovim compilerom je slaba. Zato danas naj?e??e kori?teni simulatori PicoBlazea, koji ciljaju na to da ga simuliraju u VHDL-ovske detalje, sadr?e elemente zatvorenog koda. Dakle, to su programi za koje je ilegalno provjeravati da nisu zlonamjerni. Upitno je mogu li nam ekonomski faktori i ameri?ki pravni sustav garantirati da Xilinxovi programi nisu Trojanski konji.
Po autoru ovog teksta, jedna od glavnih mana dana?njih simulatora PicoBlazea je upravo to ?to oni ciljaju na simuliranje PicoBlazea (i druge mekane procesore) u VHDL-ovske detalje. Da bi to napravili, simulatori moraju biti programi od po stotine ili ?ak i tisu?e MB-a. Ako poku?amo s interneta skinuti i na disk pohraniti na stotine MB-a ili GB-e podataka, gotovo sigurno ?emo naletjeti na neke neo?ekivane probleme (pucanje internetske veze zbog kojeg moramo krenuti ispo?etka, gre?ke u datote?nom sustavu koje ne bivaju o?ite dok ne poku?amo spremiti neku ogromnu datoteku...).
Glavna mana dana?njih simulatora PicoBlazea je to ?to ih se na ra?unalo mora instalirati da bi funkcionirali. Nije ih mogu?e pokrenuti u internetskom progledniku ili skinuti ZIP-arhivu i otpakirati je gdje ?elimo. To je osobit problem na Linuxu iz dva razloga. Prvo, instaliranje programa obi?no zauzima mjesta na SSD-u (gdje je spremljen Linux i sistemski direktorij gdje se obi?no spremaju instalirani programi, /usr/bin), a ne na HDD-u (na kojem obi?no ima daleko vi?e slobodnog mjesta, i koji se ne tro?i kada na njega pi?emo ili bri?emo s njega). Jedan od na?ina da se to rije?i je postavljanje virtualne ma?ine ?iji se virtualni tvrdi disk nalazi na HDD-u, no to je dugotrajan i kompliciran posao, a i nezgodno je ?ekati da se pokrene jo? jedan Linux kad god nam treba neki program koji nam mo?da ?esto treba. Drugo, programeri koji nemaju iskustva s radom na Linuxu obi?no pretpostavljaju da postoji samo jedan, nekakav apstraktni, Linux. Simulatori PicoBlazea obi?no su testirani na Red Hat Linuxu, i programeri vjerojatno pretpostavljaju da, ako tamo radi, radit ?e na drugim verzijama Linuxa. No to vrijedi samo za najjednostavnije programe pisane u C-u ili Assembleru, ?ak ne ni za Hello World program pisan u C++-u. Istina je da ?e program koji radi na Red Hat Linuxu vjerojatno raditi bez problema na Oracle Linuxu, CentOS-u i Scientific Linuxu, a mo?da i na Fedori. No, ako ?elite pokrenuti program za Red Hat Linux na Ubuntu Linuxu, Debianu ili Mint Linuxu (danas naj?e??e kori?tene verzije Linuxa), puno sre?e s time. Vrijedi i obratno: programi za Debian rijetko kad se mogu jednostavno pokrenuti na Oracle Linuxu. Iako postoje programi za Linux koji izvrsno rade na mnogim verzijama Linuxa (Firefox, recimo, radi savr?eno na Ubuntu Linuxu, a na Oracle Linuxu samo ima problema s prikazom MP4 videa), da bi se to postiglo trebaju programeri koji poznaju Linux u najve?e detalje, a takvi su rijetki. Ve?inom se programi za Linux na mnogim verzijama Linuxa ne daju niti instalirati. I, zapravo, instalacija je nerijetko najve?i problem. Poku?aj da se na Oracle Linux instalira Chrome pomo?u RPM datoteke skinute s Googlea (namijenjene za Fedoru) dovodi do hrpe poruka o pogre?ci, a, ipak, izvr?na datoteka Chromiuma s AppSpota funkcionira uz manje probleme. Programi otvorenog koda, kao ?to su VIM, mogu funkcionirati na mnogim verzijama Linuxa tako ?to se oslanjaju na compilere i srodne alate prisutne na Linuxu za instalaciju. No, to za napredne PicoBlaze simulatore, kojima je barem dio koda zatvoren, nije opcija.
Simulator PicoBlazea u JavaScriptu otvorenog je koda, to jest, kôd je dostupan javno na GitHubu (i, budu?i da je web-aplikacija, ne mo?e u?initi ni?ta lo?e ra?unalu ukoliko se pokrene u sigurnom internetskom pregledniku), velik je svega 160KB, i ne zahtijeva nikakve instalacije.

Struktura simulatora za PicoBlaze u JavaScriptu
Simulator PicoBlazea u JavaScriptu nema back-end (kôd koji se vrti na serveru), ve? se u cijelosti vrti u internetskom pregledniku. Njegov kôd podijeljen je u 7 datoteka, ukupno 3'200 redaka: 
    1. PicoBlaze.html - sadr?i HTML kôd i CSS kôd te JavaScript vezan za postavljanje izgleda web-aplikacije, sintaksno bojanje asemblerskog koda, postavljanje simulatorske niti, komunikaciju izme?u tokenizera, parsera, pretprocesora i asemblera (u svijetu compilera to se zove driver) te za dohva?anje primjera asemblerskog koda s autorovoga GitHub profila. Ta datoteka ima 1'000 redaka koda. CSS koji se koristi je relativno primitivan (recimo, nema medijskih upita), za pozicioniranje elemenata na ekranu uglavnom se koristi JavaScript. Iskreno, ne da mi se u?iti napredni CSS kad izgleda da mogu i bez toga.
    2. TreeNode.js - sadr?i JavaScript klasu pod nazivom TreeNode, koja sadr?i metode vezane za evaluaciju parsiranih aritmeti?kih izraza, metodu za ispis LISP-ovih izraza radi debugiranja parsera, te metode za pretragu struktura koje radi pretprocesor. Ta datoteka ima 100 redaka koda.
    3. assembler.js - radi semanti?ku provjeru asemblerskog koda (recimo, je li prvi argument naredbe load uistinu registar) pomo?u strukture koje radi parser te spaja strukturu koju radi parser i strukture koje radi pretprocesor u strojni kod u heksadekadskom obliku. Ima 1'050 redaka koda. Pretvoriti strojni kod u heksadecimalnom obliku u binarni oblik (kakav razumije PicoBlaze) nije lagano u JavaScriptu, jer najmanja jedinica memorije koja se u JavaScriptu mo?e adresirati jest byte, 8 bitova, a svaka naredba u strojnom kodu PicoBlazea je 18 bitova, ?to nije cijeli broj byteova. Za razliku od ostalih potprograma, assembler.js i simulator.js svoje rezultate ne vra?aju kao povratnu vrijednost funkcije, nego ih pi?u u globalne varijable.
    4. parser.js - Parser je dio compilera (u ovom slu?aju, compilera za asemblerski jezik) koji drugim dijelovima compilera ka?e koja je rije? u programskom jeziku gramati?ki povezana s kojom drugoj rije?i. To radi tako ?to radi strukturu zvanu AST, abstract syntax tree, apstraktno sintaksno stablo. Kao obja?njenje za?to je to potrebno, uzmite u obzir sljede?u re?enicu iz Cezarovog De Bello Gallico (koja je bila na ?upanijskom natjecanju iz latinskog jezika 2016. godine, 6. svitak, 24. poglavlje): Ea, quae fertilissima totius Germaniae sunt, loca Graecis aliquibus nota fama esse loquuntur. S kojom je rije?i povezana rije? nota (poznata)? Ako znate samo malo latinskog, vjerojatno biste pomislili da je rije? nota gramati?ki povezana s fama (slava, glasina), da je to pleonazam i da rije? nota treba zanemariti. No, to je krivo. Rije? nota povezana je s rije?ju loca (mjesta, lokacije). Rije? fama je u ablativu jednine (ablativ je latinski pade? koji odgovara hrvatskom lokativu, instrumentalu te genitivu u zna?enju iz koga ili iz ?ega), a igrom slu?aja na latinskom jeziku akuzativ mno?ine u drugoj deklinaciji u srednjem rodu i ablativ jednine prve deklinacije imaju isti nastavak  (to jest, isti su u pisanom latinskom ako ne ozna?avamo naglaske, ina?e je a u nastavku u fama dugo, a u nota kratko), re?enica zna?i: Ka?u (loquuntur) da su (esse) ona (ea) mjesta, koja (quae) su (sunt) najplodnija (fertilissima) u cijeloj (totius) Germaniji, nekim (aliqubus) Grcima (Graecis) glasinom poznata. Glagol biti je jednom u prezentu (sunt), a jednom u infinitivu (esse), zbog jednog neva?nog detalja iz latinske sintakse koji se zove akuzativ s infinitivom. Glagol loquuntur je takozvani deponentni glagol, morfolo?ki je pasivan, a semanti?ki aktivan (zato je nastavak -untur, a ne -unt). Pridjev totus (cijeli) ima nepravilni genitiv jednine na -ius (totius), kao jo? nekolicina latinskih pridjeva. Za slu?ajeve kad se takve stvari dogode u programskom jeziku, parser bi spojio rije?i nota i loca u jedan ?vor sintaksnog stabla. Ta mi je re?enica ostala u sje?anju jer mi je profesor pri?ao da je ispravljao test neke u?enice koja je tu re?enicu krivo prevela ne?to kao Najplodnija Njemica..., no to bi se ve? te?ko dalo objasniti kao rezultat pogre?nog parsiranja. Ta su se najplodnija mjesta u Germaniji nalazila oko nekakve ?ume. Kasnije je u tom tekstu bilo Ea (tamo = u toj ?umi) nascuntur (ra?aju se) alces (sjeverni jeleni)..., a ona je to navodno prevela s Ona ra?a sjeverne jelene..., a to opet nije stvar krivog parsiranja kad po morfologiji vidimo da je nascuntur pasiv i vidimo da je u mno?ini. Parser za asemblerski jezik bio je mnogo lak?i za napisati nego parser za AEC, moj programski jezik. Parser za moj programski jezik2 duga?ak je 950 redaka, dok datoteka parser.js sadr?i 125 redaka. Zapravo, jedino ?to je nu?no parsirati u asembleru za PicoBlaze jesu aritmeti?ki izrazi. Algoritam napisan u datoteci parser.js ide ovako:
        1. Prona?i parove otvorenih i zatvorenih zagrada u nizu koji ti je dao tokenizer. Parovi otvorenih i zatvorenih zagrada nalaze se, naime, u aritmeti?kim izrazima te kao oznaka da je ono ?to se nalazi u registru pokaziva?. Kada na?e? neki par zagrada, prebaci ono izme?u zagrada u novi niz, obri?i to iz originalnog niza, i pokreni rekurziju s novim nizom kao argumentom. Ako zagrade nisu dobro zatvorene, javi poruku o pogre?ci. U parseru za svoj programski jezik zadao sam da se i zagrade obri?u iz sintaksnog stabla. U asemblerskom jeziku za PicoBlaze to ne bi imalo smisla, budu?i da zagrade imaju zna?enje da je u registru pokaziva?, pa bih si time samo zakomplicirao asembler. Potprogram u parser.js zato za svaki par zagrada ume?e ?vor s tekstom (), i njegova su djeca (polje children iz klase TreeNode) niz koji vrati rekurzija.
        2. Prolazi kroz niz koji ti je dao tokenizer i za svaku rije? provjeri nalazi li se na popisu mnemonika (tako se tradicionalno zovu glagoli u asemblerskom jeziku3) ili pretprocesorskih direktiva. Ti se popisi nalaze u datoteci PicoBlaze.html. Ako se rije? na koju si upravo nai?ao nalazi jednom od tih popisa, a nije da je rije? jednaka enable ili disable i da je du?ina niza jednaka jedinici (jer enable i disable, osim ?to mogu biti glagoli, mogu biti i, recimo to tako, prilozi glagola returni), premjesti sve izme?u tog glagola i znaka za novi red (isklju?ivo) u novi niz, pokreni rekurziju i proglasi ono ?to rekurzija vrati djecom ?vora u kojem je taj glagol. To funkcionira zato ?to svaka re?enica u asemblerskom jeziku po?inje s glagolom te, osim u aritmeti?kim izrazima, ne postoji lingvisti?ka rekurzija, to jest, u asemblerskom jeziku ne postoje slo?ene re?enice. Kao zanimljivost, neki lingvisti (ustvari, danas mo?da samo Daniel Everett) tvrde da je pirahanski jezik, slabo dokumentirani jezik iz Brazila, takav.
        3. Parsiraj aritmeti?ke izraze. Prvo se baktaj s unarnim operatorima, njih se detektira kao tokeni + (plus) i - (minus) ispred kojih se ne nalazi ni?ta (prvi token u nizu), ili se ispred njih nalaze tokeni , (zarez), ( (otvorena zagrada) ili token koji sadr?i znak za novi red. Zatim konstruiraj lambda-funkciju parseBinaryOperators koja prima niz operatora te prolazi originalni niz u potrazi za njima, i, kada ih na?e, njihove susjedne tokene progla?ava njihovom djecom i bri?e iz niza. Ta se lambda-funkcija prvo poziva za niz samo s operatorom potenciranja, ^, jer on ima najve?i prioritet, zatim se poziva za operatore mno?enja i dijeljenja, * i /, te kona?no za zbrajanje i oduzimanje, + i -. Parser za moj programski jezik mora paziti na razliku izme?u lijevo-asocijativnih operatora i desno-asocijativnih operatora. No, budu?i da su svi aritmeti?ki operatori lijevo-asocijativni, to ovdje nije potrebno.
Na kraju bismo trebali dobiti asemblerski kod u obliku LISP-ovog S-izraza, koje JavaScript u  datoteci PicoBlaze.html za potrebe tra?enja gre?aka u asembleru ispisuje na preglednikovu konzolu JavaScriptinom naredbom console.log. Profesor Ivan Aleksi predlagao mi je da ne ugradim podr?ku za aritmeti?ke izraze u svoj asembler i da ni ne parsiram asemblerski kod nego da ga pretvorim u dvodimenzionalno polje stringova, gdje svaki redak iz asemblerskog koda predstavlja jedno jednodimenzionalno polje u tom dvodimenzionalnom polju, da prvi string u tom jednodimenzionalnom polju bude potencijalni naziv labela ili prazan string, da drugi string bude glagol, i tako dalje. Ja mislim da je raditi na taj na?in jo? kompliciranije.
    5. preprocessor.js - Prima strukturu koju pravi parser i odre?uje adrese labelsa. To je znatno lak?e napraviti za PicoBlaze nego za Intelove i AMD-ove (x86) procesore, jer su za PicoBlaze sve naredbe u strojnom jeziku jednake du?ine (18 bitova), pa mo?emo svaki puta kada nai?emo na mnemoniku u AST-u pove?ati trenutnu adresu za jedan. Za x86, taj algoritam ne bi bio to?an, jer, recimo, asemblerska naredba int 0x3 (u doba DOS-a slu?ila za pozivanje debuggera) ima 8 bitova (u heksadekadskom formatu je cc), dok int 0x20 (u doba prvih verzija DOS-a slu?ila za zatvaranje programa) ima 16 bitova (u heksadekadskom formatu je 20cd), a mov rax,[3*rbx+7] ima 40 bitova (heksadekadski 8b485b440007). Potprogram preprocessor.js tako?er izvr?ava i sprema rezultate direktiva constant i namereg (za preimenovanje registara u smislene nazive) u Map (klasa ?iji objekti sadr?avaju parove klju?-vrijednost, dostupna u standardnoj biblioteci JavaScripta od vremena Internet Explorera 11). Primijetite da se pretprocesor u kontekstu asemblera jako razlikuje od pretprocesora u kontekstu compilera. U compilerima, pretprocesor se pokre?e jo? prije tokenizera. U asemblerima, pretprocesor se pokre?e nakon parsera, ali prije jezgre asemblera. U mnogim je asemblerima pretprocesor Turing-potpun (Turing-complete), ?to je rijedak slu?aj u vi?im programskim jezicima (koliko znam, to jo? vrijedi jedino za PERL). Zapravo, to se u vi?im programskim jezicima smatra lo?im jer programske jezike ne treba mo?i parsirati samo compiler za taj programski jezik, nego i drugi alati za programiranje. Jedna od ?estih kritika PERL-a je upravo Only PERL can parse PERL.. Potprogram preprocessor.js ima 140 redaka.
    6. simulator.js - Taj se potprogram pokre?e u zasebnoj dretvi kad pritisnemo tipku play ili fast forward, a u istoj dretvi ako pritisnemo tipku single step. On ?ita strojni kod u heksadekadskom obliku koji je u globalni objekt machineCode (deklariran u PicoBlaze.html) upisao potprogram assembler.js, te simulira PicoBlaze pi?u?i i ?itaju?i iz memorije (globalni objekt memory tipa Uint8Array deklariran u PicoBlaze.html), registara (niz, zvan registers, od dva globalna objekta tipa  Uint8Array deklarirana u  PicoBlaze.html) i zastavica (gloablnih nizova flagC, flagZ te globalnih varijabli flagIE i regbank), pi?u?i u izlaze (globalni objekt output), ?itaju?i, koriste?i DOM, ulaze iz one tablice s 256 HTML-ovih input-a, te upravljaju?i stogom callStack. Potprogram simulator.js ima 680 redaka. Razmi?ljao sam isprva o tome da jezgru simulatora napi?em u svom programskom jeziku, a ne u JavaScriptu (preko svog compilera koji cilja WebAssembly, standardizirani JavaScript bytecode), no odlu?io sam da to ipak ne radim tako. Naime, compiler za moj programski jezik kompatibilan je samo s najnovijim internetskim preglednicima, ne mo?e ciljati niti Microsoft Edge, a, rebus sic stantibus, danas tako ne?to nije opcija ako ?elimo da nam web-aplikacija bude popularna. Uostalom, sigurno bih naletjeo na neke probleme vezane za komunikaciju potprograma pisanih u JavaScriptu i potprograma pisanih u mom programskom jeziku, tako da je upitno bih li se manje namu?io pi?u?i taj simulator u svom programskom jeziku.
    7. tokenizer.js - Tokenizer je dio compilera koji ka?e drugim dijelovima compilera gdje zavr?ava koja rije?, a gdje po?inje druga, u programskom jeziku. Rije?i u programskom jeziku zovu se tokeni (engleski token izvan svijeta informatike zna?i oznaka). U programskim jezicima rije?i ne moraju nu?no biti odvojene razmacima, nego ve?ina programskih jezika koristi malo kompleksnije mehanizme odvajanja rije?i. Velika ve?ina programskih jezika koristi mehanizam odvajanja rije?i koji podsje?a na japansko pismo. Naime, japansko pismo ima tri skupa znakova: hiragana, katakana i kand?i. Kand?i su kineski znakovi i koriste se za pisanje korijena rije?i. Katakana je slogovno pismo koje se koristi za pisanje korijena stranih rije?i ili onomatopeja. Hiragana je slogovno pismo koji se koristi za pisanje gramati?kih afiksa (prefiksa i sufiksa). Ve?ina gramati?kih afikasa u japanskom su sufiksi, tako da, kada do?emo do nekog hiraganskog znaka, znamo da je to nastavak prethodne rije?i, a ne nova rije?. S druge strane, ako nai?emo na kineski znak ili katakanski znak nakon niza hiraganskih znakova, to je naj?e??e nova rije?. Sli?an postupak za odvajanje rije?i postoji u ve?ini programskih jezika. Potprogram tokenizer.js ima 95 linija. Tokenizer za moj programski jezik4, za usporedbu, ima 260 linija. Jedna od glavnih razlika izme?u algoritma koji sam koristio za svoj programski jezik i algoritma koji sam koristio za PicoBlaze je ta ?to u PicoBlazeu nisam poku?avao zapisivati broj stupca (column number), jer su svi reci u asemblerskom jeziku kratki, pa podaci o stupcima gdje po?inje koji token ne?e previ?e pomo?i u tra?enju pogre?ke. Tako?er, tokenizer za moj programski jezik ne smatra znak za novi red tokenom, dok tokenizer za PicoBlazeov asemblerski jezik smatra. Tokenizer za moj programski jezik mora se brinuti o escape-sequence znakovima u stringovima (\"...), dok tokenizer za PicoBlazeov asembler ne mora. U compileru za moj programski jezik tokenizer zamjenjuje tokene poput 'a' odgovaraju?im ASCII vrijednostima (?to mo?da i nije bila dobra ideja, jer poruke o pogre?kama tipa unexpected token zbog toga mogu biti nejasne), u asembleru za PicoBlaze to radi potprogram TreeNode.js.
Osim tih datoteka, u GitHub repozitoriju nalaze se slike napravljene u GIMP-u (Linuxov Paint) i Inkscapeu (Linuxov Publisher) te primjeri programa za PicoBlaze koje je mogu?e dohvatiti klikaju?i na examplese. Slike koje predstavljaju play, pause, stop, fast forward i single step su u SVG formatu i ure?ivane u Inkscapeu. Ikona za Assembler Test u GIF je formatu i ure?ivana u GIMP-u. Pozadina je fotografija PicoBlaze ra?unala koju je profesor Ivan Aleksi uklju?io u svoju prezentaciju, posvijetljena u GIMP-u i spremljena kao GIF.

Primjeri programa za PicoBlaze
Web-aplikacija nudi tri primjera programa za PicoBlaze. Prvi se zove Fibonacci Sequence. On ispisuje Fibonaccijeve brojeve koji stanu u jedan byte (koliko su veliki PicoBlazeovi registri, svih 32), dakle, manje od 256. One koje se mogu prikazati u BCD (binary coded decimal, tako se u 8 bitova mogu prikazati brojevi manji od 100) formatu tako i ispisuje, a, one koji se ne mogu, ispisuje u heksadekadskom formatu. Tako?er koristi bitovne operacije da bi izbrojao koliko ima jedinica u binarnom zapisu svakog od tih brojeva. Kad zavr?i, javlja da je zavr?io naredbom return, ?to ne bi pro?lo na pravom PicoBlazeu. Da bi ispisao broj u novi red, on ispisuje na port sa sljede?om adresom, ?to na pravom PicoBlazeu isto ne bi pro?lo. Ima 116 redaka, uklju?uju?i brojne komentare. Program Gray Code koristi bitovne operacije da bi binarne brojeve pretvarao u i iz Grayevog koda. To je na?in kodiranja brojeva koji se ?esto koristi u digitalnoj elektronici, ima svojstvo da se susjedni brojevi razlikuju samo u jednoj binarnoj znamenki. Recimo, brojanje od 0 do 10 u binarnom sustavu ide (promijenjene znamenke u susjednim brojevima su boldirane, a lijeve nule, koje nije potrebno pisati, u zagradama su): (000)0, (000)1, (00)10, (00)11, (0)100, (0)101, (0)110, (0)111, 1000, 1001, 1010. U Grayevom kodu ti brojevi su: (000)0, (000)1, (00)11, (00)10, (0)110, (0)111, (0)101, (0)100, 1100, 1101, 1111. To svojstvo je korisno jer ne moramo ra?unati na to da su ra?unala koja izmjenjuju poruke potpuno sinkronizirana, da jedno ra?unalo po?ne ?itati broj sa ?ice tek kad ga je drugo ra?unalo ve? dovr?ilo mijenjati. Taj program koristi algoritam opisan na engleskoj Wikipediji, te se vrti u beskona?noj petlji ?itaju?i s ulaza. Ima 25 redaka. Program Assembler Test je besmislen program koji koristi sve naredbe koje podr?ava assembler za PicoBlaze, da bude lak?e testirati assembler. Ako se pokrene u simulatoru, vrti se u beskona?noj petlji. Ima 83 reda.

Mane simuliranja PicoBlazea u JavaScriptu
Naravno, taj simulator PicoBlazea ?to sam ga napravio u JavaScriptu ima i svoje nedostatke naspram fully-featured simulatora. Prvo, on ne poku?ava interpretirati VHDL, tako da ne mo?e simulirati PicoBlazeove s modificiranim VHDL kodom (osim ako ne promijenimo JavaScript, ali opet nam to ne?e pomo?i da na?emo gre?ke u VHDL kodu). Drugo, grafi?ko su?elje mu je mnogo manje efektivno nego su?elje koje pru?aju naj?e??e kori?teni simulatori PicoBlazea. Dobro je poznato da je u web-aplikacijama te?ko napraviti dobro korisni?ko su?elje. Profesor Ivan Aleksi mi je predlagao da probam koristiti neki JavaScript radni okvir (framework) za pravljenje korisni?kih su?elja, kao ?to je ReactJS, no za njih treba vremena da se nau?e, a i pitanje je koliko uistinu poma?u. Tre?a je mana ?to je nemogu?e napraviti realisti?ni tajming. Jedna od prednosti PicoBlazea za kori?tenje u ugra?enim sustavima, gdje trebaju mala ra?unala, jest upravo to ?to je lagano odrediti koliko ?e se dugo neki komad koda izvr?avati ako znamo na koliko MHz-a radi (PicoBlaze mo?e raditi na frekvenciji do oko 130 MHz), svaka instrukcija traje to?no dva takta. U JavaScriptu je to nemogu?e simulirati, jer JavaScript, na primjer, ima sakupljanje sme?a koje se pokre?e (?to se JavaScriptskog programa ti?e) nedeterministi?ki. Iako moj simulator nije dostatan za neke potrebe, smatram da je dostatan za potrebe studenata i da ?e ih spasiti hasslea instalacije naprednijih simulatora.

Zahvale
Posebno zahvaljujem profesoru Ivanu Aleksiju ?to me je potakao da ovo napravim i ?to je sakupio informacije na internetu potrebne za to. Zahvaljujem i programerima koji su napravili internetski servis LGTM, stati?ki analizer za JavaScript koji me je upozorio na neke gre?ke koje sam napravio. JavaScript je relativno lo? programski jezik i takvi su alati korisni.
